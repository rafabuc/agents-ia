"""
Vulnerability Scanner Tool for Security Agent
"""

import json
import subprocess
import os
from typing import Dict, Any, List, Optional
from pathlib import Path

from ...base.tools import BaseDevOpsTool


class VulnerabilityScanner(BaseDevOpsTool):
    """Tool for comprehensive vulnerability scanning"""

    name: str = "vulnerability_scanner"
    description: str = "Perform vulnerability scanning on code, containers, and infrastructure"

    def _run(self, action: str, **kwargs) -> Dict[str, Any]:
        """Execute vulnerability scanning operations"""
        self.log_execution("vulnerability_scanner", {"action": action, "kwargs": kwargs})

        try:
            if action == "scan_code":
                return self._scan_source_code(
                    kwargs.get("path", "."),
                    kwargs.get("language", "python")
                )
            elif action == "scan_container":
                return self._scan_container_image(kwargs.get("image_name"))
            elif action == "scan_dependencies":
                return self._scan_dependencies(
                    kwargs.get("manifest_path"),
                    kwargs.get("package_manager", "pip")
                )
            elif action == "scan_infrastructure":
                return self._scan_infrastructure(kwargs.get("config_path"))
            elif action == "generate_report":
                return self._generate_vulnerability_report(kwargs.get("scan_results"))
            else:
                return {"success": False, "error": f"Unknown action: {action}"}

        except Exception as e:
            return {"success": False, "error": str(e)}

    def _scan_source_code(self, path: str, language: str) -> Dict[str, Any]:
        """Scan source code for vulnerabilities using multiple tools"""
        try:
            results = {
                "bandit_results": None,
                "semgrep_results": None,
                "safety_results": None,
                "summary": {"total_issues": 0, "high_severity": 0, "medium_severity": 0, "low_severity": 0}
            }

            # Python-specific scanning with Bandit
            if language.lower() == "python":
                bandit_result = self._run_bandit_scan(path)
                results["bandit_results"] = bandit_result

            # Multi-language scanning with Semgrep
            semgrep_result = self._run_semgrep_scan(path)
            results["semgrep_results"] = semgrep_result

            # Dependency scanning with Safety (Python)
            if language.lower() == "python":
                safety_result = self._run_safety_scan(path)
                results["safety_results"] = safety_result

            # Calculate summary
            total_issues = 0
            high_count = medium_count = low_count = 0

            for tool_result in [results["bandit_results"], results["semgrep_results"], results["safety_results"]]:
                if tool_result and tool_result.get("success"):
                    issues = tool_result.get("issues", [])
                    total_issues += len(issues)
                    for issue in issues:
                        severity = issue.get("severity", "low").lower()
                        if severity in ["high", "critical"]:
                            high_count += 1
                        elif severity == "medium":
                            medium_count += 1
                        else:
                            low_count += 1

            results["summary"] = {
                "total_issues": total_issues,
                "high_severity": high_count,
                "medium_severity": medium_count,
                "low_severity": low_count,
                "scan_path": path,
                "language": language
            }

            return {
                "success": True,
                "scan_type": "source_code",
                "results": results
            }

        except Exception as e:
            return {"success": False, "error": str(e)}

    def _run_bandit_scan(self, path: str) -> Dict[str, Any]:
        """Run Bandit security scan on Python code"""
        try:
            cmd = ["bandit", "-r", path, "-f", "json", "-q"]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)

            if result.returncode in [0, 1]:  # 0 = no issues, 1 = issues found
                try:
                    bandit_output = json.loads(result.stdout)
                    issues = []

                    for issue in bandit_output.get("results", []):
                        issues.append({
                            "file": issue.get("filename"),
                            "line": issue.get("line_number"),
                            "severity": issue.get("issue_severity", "").lower(),
                            "confidence": issue.get("issue_confidence", "").lower(),
                            "description": issue.get("issue_text"),
                            "test_id": issue.get("test_id"),
                            "cwe": issue.get("issue_cwe", {}).get("id") if issue.get("issue_cwe") else None
                        })

                    return {
                        "success": True,
                        "tool": "bandit",
                        "issues": issues,
                        "metrics": bandit_output.get("metrics", {})
                    }
                except json.JSONDecodeError:
                    return {"success": False, "error": "Failed to parse Bandit output"}
            else:
                return {"success": False, "error": result.stderr}

        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Bandit scan timed out"}
        except FileNotFoundError:
            return {"success": False, "error": "Bandit not installed"}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def _run_semgrep_scan(self, path: str) -> Dict[str, Any]:
        """Run Semgrep security scan"""
        try:
            cmd = ["semgrep", "--config=auto", "--json", "--quiet", path]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)

            if result.returncode == 0:
                try:
                    semgrep_output = json.loads(result.stdout)
                    issues = []

                    for finding in semgrep_output.get("results", []):
                        issues.append({
                            "file": finding.get("path"),
                            "line": finding.get("start", {}).get("line"),
                            "severity": finding.get("extra", {}).get("severity", "info").lower(),
                            "description": finding.get("extra", {}).get("message"),
                            "rule_id": finding.get("check_id"),
                            "category": finding.get("extra", {}).get("metadata", {}).get("category")
                        })

                    return {
                        "success": True,
                        "tool": "semgrep",
                        "issues": issues,
                        "rules_used": len(set(issue.get("rule_id") for issue in issues))
                    }
                except json.JSONDecodeError:
                    return {"success": False, "error": "Failed to parse Semgrep output"}
            else:
                return {"success": False, "error": result.stderr or "Semgrep scan failed"}

        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Semgrep scan timed out"}
        except FileNotFoundError:
            return {"success": False, "error": "Semgrep not installed"}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def _run_safety_scan(self, path: str) -> Dict[str, Any]:
        """Run Safety scan for Python dependencies"""
        try:
            # Look for requirements files
            req_files = [
                os.path.join(path, "requirements.txt"),
                os.path.join(path, "Pipfile"),
                os.path.join(path, "pyproject.toml")
            ]

            req_file = None
            for rf in req_files:
                if os.path.exists(rf):
                    req_file = rf
                    break

            if not req_file:
                return {"success": False, "error": "No requirements file found"}

            cmd = ["safety", "check", "--json", "-r", req_file]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)

            # Safety returns non-zero exit code when vulnerabilities are found
            if result.stdout:
                try:
                    safety_output = json.loads(result.stdout)
                    issues = []

                    for vuln in safety_output:
                        issues.append({
                            "package": vuln.get("package"),
                            "version": vuln.get("installed_version"),
                            "vulnerability_id": vuln.get("vulnerability_id"),
                            "severity": "high",  # Safety typically reports high-impact issues
                            "description": vuln.get("advisory"),
                            "cve": vuln.get("cve"),
                            "more_info": vuln.get("more_info_url")
                        })

                    return {
                        "success": True,
                        "tool": "safety",
                        "issues": issues,
                        "requirements_file": req_file
                    }
                except json.JSONDecodeError:
                    return {"success": False, "error": "Failed to parse Safety output"}
            else:
                return {
                    "success": True,
                    "tool": "safety",
                    "issues": [],
                    "message": "No known vulnerabilities found"
                }

        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Safety scan timed out"}
        except FileNotFoundError:
            return {"success": False, "error": "Safety not installed"}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def _scan_container_image(self, image_name: str) -> Dict[str, Any]:
        """Scan container image for vulnerabilities using Trivy"""
        try:
            if not image_name:
                return {"success": False, "error": "Image name is required"}

            cmd = ["trivy", "image", "--format", "json", "--quiet", image_name]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=900)

            if result.returncode == 0:
                try:
                    trivy_output = json.loads(result.stdout)
                    vulnerabilities = []

                    for result_item in trivy_output.get("Results", []):
                        target = result_item.get("Target", "")
                        vulns = result_item.get("Vulnerabilities", [])

                        for vuln in vulns:
                            vulnerabilities.append({
                                "target": target,
                                "vulnerability_id": vuln.get("VulnerabilityID"),
                                "package": vuln.get("PkgName"),
                                "version": vuln.get("InstalledVersion"),
                                "fixed_version": vuln.get("FixedVersion"),
                                "severity": vuln.get("Severity", "").lower(),
                                "description": vuln.get("Description"),
                                "references": vuln.get("References", [])
                            })

                    # Calculate severity counts
                    severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "unknown": 0}
                    for vuln in vulnerabilities:
                        severity = vuln.get("severity", "unknown")
                        severity_counts[severity] = severity_counts.get(severity, 0) + 1

                    return {
                        "success": True,
                        "scan_type": "container",
                        "image": image_name,
                        "vulnerabilities": vulnerabilities,
                        "summary": {
                            "total_vulnerabilities": len(vulnerabilities),
                            "severity_distribution": severity_counts
                        }
                    }
                except json.JSONDecodeError:
                    return {"success": False, "error": "Failed to parse Trivy output"}
            else:
                return {"success": False, "error": result.stderr or "Trivy scan failed"}

        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Container scan timed out"}
        except FileNotFoundError:
            return {"success": False, "error": "Trivy not installed"}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def _scan_dependencies(self, manifest_path: str, package_manager: str) -> Dict[str, Any]:
        """Scan dependencies for known vulnerabilities"""
        try:
            if package_manager.lower() == "npm":
                return self._scan_npm_dependencies(manifest_path)
            elif package_manager.lower() == "pip":
                return self._run_safety_scan(os.path.dirname(manifest_path) if manifest_path else ".")
            else:
                return {"success": False, "error": f"Unsupported package manager: {package_manager}"}

        except Exception as e:
            return {"success": False, "error": str(e)}

    def _scan_npm_dependencies(self, manifest_path: str) -> Dict[str, Any]:
        """Scan npm dependencies for vulnerabilities"""
        try:
            package_dir = os.path.dirname(manifest_path) if manifest_path else "."

            cmd = ["npm", "audit", "--json"]
            result = subprocess.run(cmd, cwd=package_dir, capture_output=True, text=True, timeout=300)

            if result.stdout:
                try:
                    audit_output = json.loads(result.stdout)
                    vulnerabilities = []

                    advisories = audit_output.get("advisories", {})
                    for advisory_id, advisory in advisories.items():
                        vulnerabilities.append({
                            "advisory_id": advisory_id,
                            "package": advisory.get("module_name"),
                            "severity": advisory.get("severity", "").lower(),
                            "description": advisory.get("title"),
                            "recommendation": advisory.get("recommendation"),
                            "references": advisory.get("references", []),
                            "cwe": advisory.get("cwe", [])
                        })

                    metadata = audit_output.get("metadata", {})
                    vulnerabilities_count = metadata.get("vulnerabilities", {})

                    return {
                        "success": True,
                        "tool": "npm_audit",
                        "vulnerabilities": vulnerabilities,
                        "summary": {
                            "total": vulnerabilities_count.get("total", 0),
                            "critical": vulnerabilities_count.get("critical", 0),
                            "high": vulnerabilities_count.get("high", 0),
                            "medium": vulnerabilities_count.get("moderate", 0),
                            "low": vulnerabilities_count.get("low", 0)
                        }
                    }
                except json.JSONDecodeError:
                    return {"success": False, "error": "Failed to parse npm audit output"}
            else:
                return {"success": True, "vulnerabilities": [], "message": "No vulnerabilities found"}

        except subprocess.TimeoutExpired:
            return {"success": False, "error": "npm audit timed out"}
        except FileNotFoundError:
            return {"success": False, "error": "npm not installed"}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def _scan_infrastructure(self, config_path: str) -> Dict[str, Any]:
        """Scan infrastructure configuration for security issues"""
        try:
            # This would integrate with tools like Checkov, TFSec, or custom rules
            # For now, return a placeholder implementation

            issues = []

            # Scan for common infrastructure security issues
            if config_path and os.path.exists(config_path):
                # Basic file-based security checks
                with open(config_path, 'r') as f:
                    content = f.read().lower()

                    # Check for common security issues
                    if 'password' in content and '=' in content:
                        issues.append({
                            "file": config_path,
                            "severity": "high",
                            "description": "Potential hardcoded password found",
                            "recommendation": "Use environment variables or secret management"
                        })

                    if 'secret' in content and '=' in content:
                        issues.append({
                            "file": config_path,
                            "severity": "high",
                            "description": "Potential hardcoded secret found",
                            "recommendation": "Use secure secret management system"
                        })

            return {
                "success": True,
                "scan_type": "infrastructure",
                "config_path": config_path,
                "issues": issues,
                "summary": {
                    "total_issues": len(issues),
                    "high_severity": len([i for i in issues if i.get("severity") == "high"]),
                    "medium_severity": len([i for i in issues if i.get("severity") == "medium"]),
                    "low_severity": len([i for i in issues if i.get("severity") == "low"])
                }
            }

        except Exception as e:
            return {"success": False, "error": str(e)}

    def _generate_vulnerability_report(self, scan_results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate comprehensive vulnerability report"""
        try:
            report = {
                "executive_summary": {
                    "total_scans": 0,
                    "total_vulnerabilities": 0,
                    "critical_issues": 0,
                    "high_issues": 0,
                    "medium_issues": 0,
                    "low_issues": 0
                },
                "scan_details": [],
                "top_vulnerabilities": [],
                "recommendations": []
            }

            # Process scan results
            for scan_type, results in scan_results.items():
                if isinstance(results, dict) and results.get("success"):
                    report["executive_summary"]["total_scans"] += 1

                    # Extract vulnerabilities based on scan type
                    vulnerabilities = []
                    if scan_type == "source_code":
                        summary = results.get("results", {}).get("summary", {})
                        report["executive_summary"]["total_vulnerabilities"] += summary.get("total_issues", 0)
                        report["executive_summary"]["high_issues"] += summary.get("high_severity", 0)
                        report["executive_summary"]["medium_issues"] += summary.get("medium_severity", 0)
                        report["executive_summary"]["low_issues"] += summary.get("low_severity", 0)

                    elif scan_type == "container":
                        summary = results.get("summary", {})
                        report["executive_summary"]["total_vulnerabilities"] += summary.get("total_vulnerabilities", 0)
                        severity_dist = summary.get("severity_distribution", {})
                        report["executive_summary"]["critical_issues"] += severity_dist.get("critical", 0)
                        report["executive_summary"]["high_issues"] += severity_dist.get("high", 0)
                        report["executive_summary"]["medium_issues"] += severity_dist.get("medium", 0)
                        report["executive_summary"]["low_issues"] += severity_dist.get("low", 0)

                    report["scan_details"].append({
                        "scan_type": scan_type,
                        "status": "completed",
                        "results_summary": results.get("summary", {})
                    })

            # Generate recommendations
            if report["executive_summary"]["critical_issues"] > 0:
                report["recommendations"].append({
                    "priority": "immediate",
                    "action": "Address critical vulnerabilities immediately",
                    "rationale": "Critical vulnerabilities pose immediate risk"
                })

            if report["executive_summary"]["high_issues"] > 5:
                report["recommendations"].append({
                    "priority": "high",
                    "action": "Implement vulnerability management program",
                    "rationale": "High number of vulnerabilities indicates systematic issues"
                })

            return {
                "success": True,
                "report": report,
                "generated_at": "timestamp_would_be_here"
            }

        except Exception as e:
            return {"success": False, "error": str(e)}